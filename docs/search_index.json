[["index.html", "How to fit an animal model An ecologist guide Preface", " How to fit an animal model An ecologist guide Julien Martin 12-02-2021 Preface This book is a collection of tutorial from the excellent paper by (???). Instead of just copy pasting the tutorial in a new format, the tutorial have been updated to work with the newest version of the softwares and extended to present other softwares. "],["contributors.html", "Contributors", " Contributors List of people who contributed to update and extend tutorials: Eric Postma Julien Martin "],["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction The tutorials and accompanying data files are provided separately for different software packages using R: ASReml-R, gremlin, MCMCglmm and brms . You will need to carefully follow the instructions below to download the data files and install the R packages. Before beginning the tutorial, we assume the reader has successfully installed the chosen R package on their computer and has saved the required data files to an appropriate directory from which they will be read. Full instructions for how to do this are provided with software distributions. To work though the different tutorial I would recommend to create a folder where you will save your different R scripts for the tutorials. In addition, I recommand to create a subfolder data to save the files needed. "],["data.html", "1.1 Data", " 1.1 Data 1.1.1 Data files You will need to download 3 data files for the tutorial in R: gryphon.txt: data on gryphon birth weight gryphonRM.txt: data gryphonped.txt The files are available here I recommend to save the data files in a subfolder data in the folder you will use as your working directory for R and where you will save your R scripts. It should be noted that the tutorial are using this structure to read or save data. 1.1.2 Notes on data and pedigree It is always important to take time to think carefully about the strengths and potential limitations of your pedigree information before embarking on quantitative genetic analyses. Pedigree Viewer, written by Brian Kinghorn, is an extremely useful application for visualising pedigrees, and can be downloaded from: http://www-personal.une.edu.au/~bkinghor/pedigree.htm. Pedantics an R package written by Michael Morrissey and distributed through CRAN (http://cran.r-project.org/) can also be used for this and offers some nice additional features for visualising pedigree structures and generating associated statistics. Before you begin running through the tutorials, we advise taking a moment to look at the pedigree files provided with them using Pedigree Viewer or Pedantics. "],["r.html", "1.2 R", " 1.2 R describe R Briefly You should check that you have the most current version of R and R packages. You can check the number of the current version on CRAN. If you need to update (or install) R packages, use install.packages() and follow the prompted instructions. 1.2.1 R packages describe briefly the differnet r packages indicate how to load and install provide warning on cost and complexity indicating that we are just touching the surface of what they can do 1.2.1.1 asreml-r ASReml-R are commercial software applications published by VSN international (http://www.vsni.co.uk/software/asreml/). 1.2.1.2 gremlin 1.2.1.3 MCMCglmm MCMCglmm is an R package for Bayesian mixed model analysis written by Jarrod Hadfield. It is freeware distributed through CRAN (http://cran.r-project.org/). Information about the package, together with a user manual and vignettes are available at http://cran.r-project.org/web/packages/MCMCglmm/index.html . Reference: (???). This module provides some information that applies to MCMCglmm-based analyses in general, but that will not be included in other tutorials. Most importantly, this applies to some of the simplest waysof determining the performance of a run using MCMCglmm, i.e., verification of the validity of of the posterior distribution. This tutorial is not a substitute for working through the MCMCglmm course notes, which is available from CRAN (the Comprehensive R ArchiveNetwork, http://cran.r-project.org/, or can be accessed in R using the command vignette(“CourseNotes”,“MCMCglmm”)). These tutorials do not introduce one of the main advantages of using MCMCglmm for analyses of data from natural populations -the ability to properly model non-normal responses. These capabilities are introduced inthe documentation that is distributed with MCMCglmm, and available from CRAN. 1.2.1.4 brms "],["univariate-animal-model.html", "Chapter 2 Univariate animal model", " Chapter 2 Univariate animal model This tutorial will demonstrate how to run a univariate animal model to estimate genetic variance in birth weight in the mighty gryphons. "],["scenario-and-data.html", "2.1 Scenario and data", " 2.1 Scenario and data 2.1.1 Scenario In a population of gryphons there is strong positive selection on birth weight with heavier born individuals having, on average higher fitness. To find out whether increased birth weight will evolve in response to the selection, and if so how quickly, we want to estimate the heritability of birth weight. 2.1.2 Data files Open gryphonped.txt and gryphon.txt in your text editor. The structure and contents of these files is fairly self-explanatory. The pedigree file gryphonped.txt contains three columns containing unique IDs that correspond to each animal, its father, and its mother. Note that this is a multigenerational pedigree, with the earliest generation (for which parentage information is necessarily missing) at the beginning of the file. For later-born individuals maternal identities are all known but paternity information is incomplete (a common situation in real world applications). The phenotype data, as well as additional factors and covariates that we may wish to include in our model are contained in gryphon.txt. Columns correspond to individual identity (animal), maternal identity (mother), year of birth (byear), sex (sex, where 1 is female and 2 is male), birth weight (bwt), and tarsus length (tarsus). Each row of the data file contains a record for a different offspring individual. Note that all individuals included in the data file must be included as offspring in the pedigree file. We can read teh data file, using read.csv() which consider by default that NA is the symbol for missing values and that the first line of the file contains the column headers. It is a good idea to make sure that all variables are correctly assigned as numeric or factors: gryphon$animal &lt;- as.factor(gryphon$animal) gryphon$mother &lt;- as.factor(gryphon$mother) gryphon$byear &lt;- as.factor(gryphon$byear) gryphon$sex &lt;- as.factor(gryphon$sex) gryphon$bwt &lt;- as.numeric(gryphon$bwt) gryphon$tarsus &lt;- as.numeric(gryphon$tarsus) Similarly we can read in the pedigree file, using read.csv() which consider by default that NA is the symbol for missing values and that the first line of the file contains the column headers. ## &#39;data.frame&#39;: 1309 obs. of 3 variables: ## $ id : int 1306 1304 1298 1293 1290 1288 1284 1283 1282 1278 ... ## $ father: int NA NA NA NA NA NA NA NA NA NA ... ## $ mother: int NA NA NA NA NA NA NA NA NA NA ... gryphonped$id&lt;-as.factor(gryphonped$id) gryphonped$father&lt;-as.factor(gryphonped$father) gryphonped$mother&lt;-as.factor(gryphonped$mother) Now that we have imported the data and the pedigree file, we are ready to fit an animal model. "],["asreml-r-1.html", "2.2 Asreml-R", " 2.2 Asreml-R 2.2.1 Running the model First we need to load the asreml library: library(asreml) To be able to fit an animal model Asreml-r needs (the inverse of) the relationship matrix: ainv &lt;- ainverse(gryphonped) We are now ready to specify our first model: model1 &lt;- asreml(fixed = bwt ~ 1, random =~vm(animal, ainv), residual=~idv(units), data=gryphon, na.action = na.method(x=&quot;omit&quot;, y=&quot;omit&quot;)) ## Model fitted using the sigma parameterization. ## ASReml 4.1.0 Fri Feb 12 00:26:51 2021 ## LogLik Sigma2 DF wall cpu ## 1 -4128.454 1.0 853 00:26:51 0.0 ## 2 -3284.272 1.0 853 00:26:51 0.0 ## 3 -2354.992 1.0 853 00:26:51 0.0 ## 4 -1710.357 1.0 853 00:26:51 0.0 ## 5 -1363.555 1.0 853 00:26:51 0.0 ## 6 -1263.516 1.0 853 00:26:51 0.0 ## 7 -1247.854 1.0 853 00:26:51 0.0 ## 8 -1247.185 1.0 853 00:26:51 0.0 ## 9 -1247.183 1.0 853 00:26:51 0.0 In this model, bwt is the response variable and the only fixed effect is the mean (the intercept, denoted as 1). The only random effect we have fitted is animal, which will provide an estimate of \\(V_A\\). Our random animal effect is connected to the inverse related matrix ainv. data= specifies the name of the dataframe that contains our variables. Finally, we tell asreml() what to when it encounters NAs in either the dependent or predictor variables (in this case we choose to remove the records). A note of the specification of the structure of the residuals: This simple univariate model will run fine without residual=~idv(units). However, if you are going to use vpredict() to calculate the heritability (see below), not specifying the residuals in this way will result in a standard error for the heritability that is incorrect. To see the estimates for the variance components, we run: summary(model1)$varcomp ## component std.error z.ratio bound %ch ## vm(animal, ainv) 3.395398 0.6349915 5.347154 P 0 ## units!units 3.828602 0.5185919 7.382687 P 0 ## units!R 1.000000 NA NA F 0 We fitted a single random effect so have partitioned the phenotypic variance into two components. The vm(animal, ainv) variance component is \\(V_A\\) and is estimated as 3.4. Given that the ratio of \\(V_A\\) to its standard error (z.ratio) is considerably larger than 2 (i.e. the parameter estimate is more than 2 SEs from zero) this looks likely to be highly significant. The units!units component refers to the residual variance \\(V_R\\), and units$R should be ignored. If you don’t include residual=~idv(units)in your model specification, units$R will provide you with the residual variance. 2.2.2 Estimating heritability We can calculate the \\(h^2\\) of birth weight from the components above since \\(h^2 = V_A/V_P = V_A/(V_A+V_R)\\). Thus according to this model, \\(h^2\\) = 3.4 / (3.4 + 3.83) = 0.47. Alternatively we can use the vpredict() function to calculate \\(h^2\\) and its standard error: vpredict(model1, h2.bwt ~ V1 / (V1 + V2)) ## Estimate SE ## h2.bwt 0.4700163 0.07650881 2.2.3 Adding fixed effects To add fixed effects to a univariate model simply modify the model statement. For example we might know (or suspect) that birth weight is a sexually dimorphic trait and therefore fit a model model2 &lt;- asreml(fixed = bwt ~ 1 + sex, random= ~vm(animal, ainv), residual=~idv(units), data=gryphon, na.action = na.method(x=&quot;omit&quot;, y=&quot;omit&quot;)) ## Model fitted using the sigma parameterization. ## ASReml 4.1.0 Fri Feb 12 00:26:51 2021 ## LogLik Sigma2 DF wall cpu ## 1 -3364.126 1.0 852 00:26:52 0.0 ## 2 -2702.117 1.0 852 00:26:52 0.0 ## 3 -1978.916 1.0 852 00:26:52 0.0 ## 4 -1487.834 1.0 852 00:26:52 0.0 ## 5 -1236.350 1.0 852 00:26:52 0.0 ## 6 -1172.771 1.0 852 00:26:52 0.0 ## 7 -1165.270 1.0 852 00:26:52 0.0 ## 8 -1165.093 1.0 852 00:26:52 0.0 ## 9 -1165.093 1.0 852 00:26:52 0.0 Now we can look at the fixed effects parameters and assess their significance with a conditional Wald F-test: summary(model2, coef = TRUE)$coef.fixed wald.asreml(model2, ssType=&quot;conditional&quot;, denDF=&quot;numeric&quot;) ## solution std error z.ratio ## sex_1 0.000000 NA NA ## sex_2 2.206996 0.1619974 13.62365 ## (Intercept) 6.058669 0.1718244 35.26082 ## Model fitted using the sigma parameterization. ## ASReml 4.1.0 Fri Feb 12 00:26:52 2021 ## LogLik Sigma2 DF wall cpu ## 1 -1165.093 1.0 852 00:26:52 0.0 ## 2 -1165.093 1.0 852 00:26:52 0.0 ## Calculating denominator DF ## ## Df denDF F.inc F.con Margin Pr ## (Intercept) 1 251 3491.0 3491.0 0.00000e+00 ## sex 1 831 185.6 185.6 A 2.70204e-38 The very small probability (Pr) in the Wald test above shows that sex is a highly significant fixed effect, and from the parameter estimates we can see that the average male (sex 2) is 2.2 kg (\\(\\pm\\) 0.16 SE) heavier than the average female (sex 1). However, when we look at the variance components in the model including sex as a fixed effect, we see that they have changed slightly from the previous model: summary(model2)$varcomp ## component std.error z.ratio bound %ch ## vm(animal, ainv) 3.060441 0.5243571 5.836558 P 0 ## units!units 2.938412 0.4161473 7.060991 P 0 ## units!R 1.000000 NA NA F 0 In fact since sex effects were previously contributing to the residual variance of the model, our estimate of \\(V_R\\) (denoted units!R in the output) is now slightly lower than before. This has an important consequence for estimating heritability since if we calculate \\(V_P\\) as \\(V_A\\)+\\(V_R\\) then as we include fixed effects we will soak up more residual variance driving \\(V_P\\). Assuming that \\(V_A\\) is more or less unaffected by the fixed effects fitted then as \\(V_P\\) goes down we expect our estimate of \\(h^2\\) will go up: vpredict(model2, h2.bwt ~ V1 / (V1 + V2)) ## Estimate SE ## h2.bwt 0.510171 0.07432388 Here \\(h^2\\) has increased slightly from 0.47 to 0.51. Which is the better estimate? It depends on what your question is. The first is an estimate of the proportion of variance in birth weight explained by additive effects, the latter is an estimate of the proportion of variance in birth weight after conditioning on sex that is explained by additive effects. 2.2.4 Adding random effects This is done by simply modifying the model statement in the same way. For instance fitting model3 &lt;- asreml(fixed = bwt ~ 1 + sex, random= ~vm(animal, ainv) + byear, residual=~idv(units), data=gryphon, na.action = na.method(x=&quot;omit&quot;, y=&quot;omit&quot;)) ## Model fitted using the sigma parameterization. ## ASReml 4.1.0 Fri Feb 12 00:26:52 2021 ## LogLik Sigma2 DF wall cpu ## 1 -2742.658 1.0 852 00:26:52 0.0 ## 2 -2237.268 1.0 852 00:26:52 0.0 ## 3 -1690.453 1.0 852 00:26:52 0.0 ## 4 -1328.910 1.0 852 00:26:52 0.0 ## 5 -1154.597 1.0 852 00:26:52 0.0 ## 6 -1116.992 1.0 852 00:26:52 0.0 ## 7 -1113.809 1.0 852 00:26:52 0.0 ## 8 -1113.772 1.0 852 00:26:52 0.0 ## 9 -1113.772 1.0 852 00:26:52 0.0 results in an additional variance component of birth year: summary(model3)$varcomp ## component std.error z.ratio bound %ch ## byear 0.8862604 0.2695918 3.287416 P 0 ## vm(animal, ainv) 2.7068665 0.4422140 6.121169 P 0 ## units!units 2.3092415 0.3451025 6.691466 P 0 ## units!R 1.0000000 NA NA F 0 Here the variance in bwt explained by byear is 0.886 and, based on the z.ratio, appears to be significant. Thus we would conclude that year-to-year variation (e.g., in weather, resource abundance) contributes to \\(V_P\\). Note that although \\(V_A\\) has changed somewhat, as most of what is now partitioned as a birth year effect was previously partitioned as \\(V_R\\). Thus what we have really done here is to partition environmental effects into those arising from year-to-year differences versus everything else, and we do not really expect much change in \\(h^2\\) (since now \\(h^2 = V_A/ (V_A+V_{BY}+V_R)\\)). However, we get a somewhat different result if we also add a random effect of mother to test for maternal effects: model4 &lt;- asreml(fixed = bwt ~ 1 + sex, random= ~vm(animal, ainv) + byear + mother, residual=~idv(units), data=gryphon, na.action = na.method(x=&quot;omit&quot;, y=&quot;omit&quot;)) ## Model fitted using the sigma parameterization. ## ASReml 4.1.0 Fri Feb 12 00:26:52 2021 ## LogLik Sigma2 DF wall cpu ## 1 -2033.178 1.0 852 00:26:52 0.0 ## 2 -1723.734 1.0 852 00:26:52 0.0 ## 3 -1396.354 1.0 852 00:26:52 0.0 ## 4 -1193.012 1.0 852 00:26:52 0.0 ## 5 -1107.946 1.0 852 00:26:52 0.0 ## 6 -1095.327 1.0 852 00:26:52 0.0 ## 7 -1094.816 1.0 852 00:26:52 0.0 ## 8 -1094.815 1.0 852 00:26:52 0.0 Gives estimated variance components of summary(model4)$varcomp ## component std.error z.ratio bound %ch ## byear 0.8820313 0.2632455 3.350604 P 0 ## mother 1.1184698 0.2386239 4.687167 P 0 ## vm(animal, ainv) 2.2985320 0.4962496 4.631806 P 0 ## units!units 1.6290034 0.3714154 4.385934 P 0 ## units!R 1.0000000 NA NA F 0 Here partitioning of significant maternal variance has resulted in a further decrease in \\(V_R\\) but also a decrease in \\(V_A\\). The latter is because maternal effects of the sort we simulated (fixed differences between mothers) will have the consequence of increasing similarity among maternal siblings. Consequently they can look very much like additive genetic effects and if present, but unmodelled, represent a type of “common environment effect”\" that can - and will - cause upward bias in \\(V_A\\) and so \\(h^2\\). 2.2.5 Testing significance of random effects A final point to note in this tutorial is that while the z.ratio (component/std.error) reported is a good indicator of likely statistical significance (&gt;1.96?), the standard errors are approximate and are not recommended for formal hypothesis testing. A better approach is to use likelihood-ratio tests. For example, to test the significance of maternal effects we could compare models with and without the inclusion of maternal identity as a random effect and compare the final log-likelihoods of these models. model4$loglik ## [1] -1094.815 shows that the model including maternal identity has a log-likelihood of -1094.815, and model3$loglik ## [1] -1113.772 shows that the model excluding maternal identity has a log-likelihood of -1113.772. A test statistic equal to twice the absolute difference in these log-likelihoods is assumed to be distributed as Chi square with one degree of freedom. In this case we would conclude that the maternal effects are highly significant since: 2 \\(\\times\\) (-1094.8145793 - -1113.7719147) equals 37.9146708, and the p-value that comes with this is: 1 - pchisq(2 * (model4$loglik - model3$loglik),1) ## [1] 7.390738e-10 As P &lt; 0.0001 we would therefore conclude that the additional of maternal identity as a random effect significantly improves the model, given an increase in log-likelihood of approximately 19. "],["gremlin-1.html", "2.3 gremlin", " 2.3 gremlin TODO (maybe just bother Matthew to do it) "],["mcmcglmm-1.html", "2.4 MCMCglmm", " 2.4 MCMCglmm 2.4.1 Running the model First load MCMCglmm: library(MCMCglmm) The first model we will fit is a simple animal model with no fixed effects, and only an ‘animal’ random effect relating individuals to their additive genetic values through the pedigree. First we are going to define priors. In a way we might want to avoid using priors, because we would like all of the infromation in our analysis to come from our data. By default MCMCglmm uses improper priors, but this can cause inferential and numerical problems. We will specify priors for the animal effect and the residual variance using the following code: Ainv &lt;- inverseA(gryphonped)$Ainv prior1.1 &lt;- list( G = list(G1 = list(V = 1, nu = 0.002)), R = list(V = 1, nu = 0.002) ) This prior specification used to be used a lot because it was believed to be relatively uninformative, and is equivalent to an inverse-gamma prior with shape and scale equal to 0.001. In many cases it is relatively uninformative but when the posterior distribution for the variances has suport close to zero it can behave poorly. Parameter expanded priors (See Chapter 8 of the CourseNotes) are gaining in popularity due to their better behaviour but for the purposes of this tutorial we will stick with the inverse-gamma prior. We have told MCMCglmm to pay little heed to our prior expectaion (V) by specifying a small degree of belief parameter (nu) of 0.002. Since this is a univariate analysis, the priors are matricies of order 1 and thus nu&gt;0 is the smallest degree of belief that provides what is known as a ‘proper’ prior, avoiding numerical problems. In fact, there is a lot of information in the data regarding the marginal distributions of the parameters, and MCMCglmm will run most of the models that we suggest in these tutorials without priors. However, this is poor practice, and we will therefore use priors throughout these tutorials. We can now fit an animal model. The model to decompose variation in birth weight into genetic and residual effects is as follows: model1.1 &lt;- MCMCglmm(bwt ~ 1, random = ~ animal, pedigree = gryphonped, data = gryphon, prior = prior1.1) ## ## MCMC iteration = 0 ## ## MCMC iteration = 1000 ## ## MCMC iteration = 2000 ## ## MCMC iteration = 3000 ## ## MCMC iteration = 4000 ## ## MCMC iteration = 5000 ## ## MCMC iteration = 6000 ## ## MCMC iteration = 7000 ## ## MCMC iteration = 8000 ## ## MCMC iteration = 9000 ## ## MCMC iteration = 10000 ## ## MCMC iteration = 11000 ## ## MCMC iteration = 12000 ## ## MCMC iteration = 13000 After typing this code, MCMCglmm will run, taking about 20 seconds on a modern desk- top computer. The progress of the run will be printed to the screen. Also, note the warning message will be printed at the end of the run. This is natural too. In order for the MCMC algorithm to work, MCMCglmm must keep track of effects associated with unmeasured individuals appearing in the pedigree. This will not affect the answers, but when many unmeasured individuals exist, it can hinder the ability of the algorithm to explore the parameter space (more on this, and a solution, later). Lets have a look at the MCMCglmm outputs. First we will evaluate how confident we can be that MCMCglmm found good answers. By entering plot(model1.1$Sol) Figure 2.1: The posterior distribution of the fixed effect (the intercept, or mean) in model 1.1 in the console, we get Figure 1 (p. 5). The plot on the left shows a time series of the values of 1000 samples of the posterior distribution of the the model intercept (mean birthweight). The plot on the right shows the same data as a distribution. Complicated statistical methods for estimating population means are of course of little interest; rather, we are examining these outputs to check that MCMCglmm’s algorithms worked well for our data and for this model. The important point here is that a consistent amount of variation around a largely unchanging mean value of the intercept was obtained, and the posterior distribution of the intercept appears to be valid. More rigorous means of evaluation the independence of the samples in the posterior distribution (evaluating autocorrelation) are discussed in the MCMCglmm CourseNotes, available from CRAN. Note that your output for model 1.1 may not be identical to this due to Monte Carlo (random number) error. The posterior distributions of the the variance components are generally of more inter- est to animal model users. We can view plots of the posterior distribution for the variance components for model 1.1 by plot(model1.1$VCV) Figure 2.2: The posterior distributions of the variance components of model 1.1, based on an analysis with the default values for nitt, burnin, and thin in MCMCglmm which generates Figure 2 (p. 6). Here we see distributions of the estimates of the additive genetic (animal) and residual (units) effects. These samples contain some au- tocorrelation, i.e., trends are apparent in the left-hand plot. We can deal with this easily. We will simply re-run the model for a longer number of iterations, and sample the chain less frequently. So far we have been running MCMCglmm with its default values. These defaults are a total run length of 13000 iterations, the first 3000 of which are discarded as a ‘burn-in’ period to make sure that the converges to the part of the parameter space where the maximum likelihood exists. The remaining 10000 iterations are sampled (es- timates retained) every 10 iterations (the thinning interval). Because the values in the left-hand plots in figure 2 to appear to have different values at the beginning of the run, we might suspect that a longer burn-in period might be required. We can reduce the autocorrelation by lengthening the rest of the run and sampling the chain less frequently. The following code runs the same model 1.1, but is likely to produce better samples of the posterior distributions. This model should take about two minutes to analyze. model1.1 &lt;- MCMCglmm(bwt ~ 1, random = ~animal, pedigree = gryphonped, data = gryphon, nitt = 65000, thin = 50, burnin = 15000, prior = prior1.1, verbose = FALSE) Notice that we have now included the command verbose=FALSE in the MCMCglmm call. We will continue this throughout the tutorial so that more complete screen outputs can be included in this document without using too much space. Now produce the plots of the samples of the fixed and random effects (they have not been included in this document). Note that the autocorrelation is much reduced. A more compact way to evaluate the validity of the posterior distributions is to calculate autocorrelation among samples, as follows: autocorr.diag(model1.1$VCV) ## animal units ## Lag 0 1.000000000 1.00000000 ## Lag 50 0.131784499 0.15366694 ## Lag 250 0.049670629 0.03678270 ## Lag 500 -0.058919704 -0.11827232 ## Lag 2500 0.005273108 -0.05706839 We will consider these levels of autocorrelation acceptable, at least for the purposes of this tutorial. Ideally, all samples of the posterior distribution should be independent, and the autocorrelation for all lag values greater than zero should be near zero. However, in practice this will not strictly be achievable for all analytical scenarios. Certainly the levels of autocorrelation observed here should not be tollerated in any formal analysis. Note that the validity of posterior distributions of any analysis should always be checked; however, for brevity we will not continue to be so consistently diligent throughout the rest of these tutorials. We can now proceed with confidence to recover some more information from these samples. We can obtain estimates of the additive genetic and residual variance by calculating the modes of the posterior distributions: posterior.mode(model1.1$VCV) ## animal units ## 3.167929 3.929677 We can obtain the Bayesian equivalent of confidence intervals by calculating the the values of the estimates that bound 95% (or any other proportion) of the posterior distri- butions: HPDinterval(model1.1$VCV) ## lower upper ## animal 2.215772 4.602692 ## units 2.865569 4.865660 ## attr(,&quot;Probability&quot;) ## [1] 0.95 We specified weak priors in this analyses. Now we will check whether or not proper priors would have influenced the results that we obtained. The simplest way to do this is to rerun the model with different priors. Here we construct priors with a larger degree of belief parameter, and we will specify that a large proportion of the variation is under genetic control: p.var &lt;- var(gryphon$bwt, na.rm = TRUE) prior1.1.2 &lt;- list(G = list(G1 = list(V = matrix(p.var * 0.05), nu = 1)), R = list(V = matrix(p.var * 0.95), nu = 1)) model1.1.2 &lt;- MCMCglmm(bwt ~ 1, random = ~animal, pedigree = gryphonped, data = gryphon, prior = prior1.1.2, nitt = 65000, thin = 50, burnin = 15000, verbose = FALSE) posterior.mode(model1.1$VCV) ## animal units ## 3.167929 3.929677 posterior.mode(model1.1.2$VCV) ## animal units ## 3.421641 3.900120 and we can therefore conclude that the difference in the priors has little effect on the outcome of the analysis. This is typical for an analysis where lots of data are available relative to the complexity of the model, but is often not the case. In all cases, it is important to check the effect of priors on conclusions drawn from a model. 2.4.2 Estimating heritability A useful property of Bayesian posterior distributions is that we can apply almost any transformation to these distributions and they will remain valid. This applies to the calculation of heritabilities. We can obtain an estimate of the heritability by applying the basic formula h 2 =V A /V P to each sample of the posterior disribution: posterior.heritability1.1 &lt;- model1.1$VCV[, &quot;animal&quot;]/(model1.1$VCV[,&quot;animal&quot;] + model1.1$VCV[, &quot;units&quot;]) HPDinterval(posterior.heritability1.1, 0.95) ## lower upper ## var1 0.3245309 0.6067394 ## attr(,&quot;Probability&quot;) ## [1] 0.95 posterior.mode(posterior.heritability1.1) ## var1 ## 0.467624 Generate a plot of the posterior distribution of this heritability estimate: plot(posterior.heritability1.1) Figure 2.3: The posterior distributions the heritability from model 1.1 2.4.3 Adding fixed effects To add effects to a univariate model we simply modify the fixed effect portion of the the model specification: model1.2 &lt;- MCMCglmm(bwt ~ sex, random = ~animal, pedigree = gryphonped, data = gryphon, prior = prior1.1, nitt = 65000, thin = 50, burnin = 15000, verbose = FALSE) We can assess the significance of sex as a fixed effect by examining its posterior distribution. posterior.mode(model1.2$Sol[, &quot;sex2&quot;]) ## var1 ## 2.203489 HPDinterval(model1.2$Sol[, &quot;sex2&quot;], 0.95) ## lower upper ## var1 1.886448 2.537313 ## attr(,&quot;Probability&quot;) ## [1] 0.95 The posterior distribution of the sex2 term does not overlap zero. Thus the we can infer that sex has a statistical effect on birthweight in this model and is a useful addition to the model, for most purposes. MCMCglmm has designated sex2 as the contrast between the two factor levels (male and female). It is also worth noting that the variance components have changed slightly: posterior.mode(model1.2$VCV) ## animal units ## 2.999294 2.788520 In fact since sex effects were previously contributing to the residual variance of the model our estimate of V R (denoted ’units’ in the output) is now slightly lower than before. This has an important consequence for estimating heritability since if we calculate V P as V A +V R then as we include fixed effects we will soak up more residual variance driving V P . Assuming that V A is more or less unaffected by the fixed effects fitted then as V P goes down we expect our estimate of h 2 will go up. posterior.heritability1.2 &lt;- model1.2$VCV[, &quot;animal&quot;]/(model1.2$VCV[,&quot;animal&quot;] + model1.2$VCV[, &quot;units&quot;]) posterior.mode(posterior.heritability1.2) ## var1 ## 0.5125448 HPDinterval(posterior.heritability1.2, 0.95) ## lower upper ## var1 0.369133 0.6425836 ## attr(,&quot;Probability&quot;) ## [1] 0.95 Here h 2 has increased slightly from 0.4829 to 0.5079 (again, your values may differ slightly due to Monte Carlo error). Which is the better estimate? It depends on what your question is. The first is an estimate of the proportion of variance in birth weight explained by additive effects, the latter is an estimate of the proportion of variance in birth weight after conditioning on sex that is explained by additive effects. Adding random effects This is done by simply modifying the model statement in the same way, but requires addition of a prior for the new random effect. For instance, we can fit an effect of birth year: prior1.3 &lt;- list(G = list(G1 = list(V = 1, nu = 0.002), G2 = list(V = 1,nu = 0.002)), R = list(V = 1, nu = 0.002)) model1.3 &lt;- MCMCglmm(bwt ~ sex, random = ~animal + byear, pedigree = gryphonped, data = gryphon, nitt = 65000, thin = 50, burnin = 15000, prior = prior1.3, verbose = FALSE) posterior.mode(model1.3$VCV) ## animal byear units ## 2.6385679 0.8993202 2.2046897 Here the variance in birth weight explained by birth year is 0.7887. Note that although V A has changed somewhat, most of what is now partitioned as a birth year effect was previously partitioned as V R . Thus what we have really done here is to partition environ- mental effects into those arising from year to year differences versus everything else, and we do not really expect much change in h 2 (since now h 2 = V A /(V A + V BY + V R )). However, we get a somewhat different result if we also add a random effect of mother to test for maternal effects: p.var &lt;- var(gryphon$bwt, na.rm = TRUE) prior1.4 &lt;- list(G = list(G1 = list(V = 1, n = 0.002), G2 = list(V = 1, n = 0.002), G3 = list(V = 1, n = 0.002)), R = list(V = 1, n = 0.002)) model1.4 &lt;- MCMCglmm(bwt ~ sex, random = ~animal + byear + mother, pedigree = gryphonped, data = gryphon, nitt = 65000, thin = 50, burnin = 15000, prior = prior1.4, verbose = FALSE) posterior.mode(model1.4$VCV) ## animal byear mother units ## 2.3128362 0.8655868 0.9579671 1.7089569 Here partitioning of significant maternal variance has resulted in a further decrease in V R but also a decrease in V A . The latter is because maternal effects of the sort we simulated (fixed differences between mothers) will have the consequence of increasing similarity among maternal siblings. Consequently they can look very much like additive genetic effects and if present, but unmodelled, represent a type of ‘common environment effect’ that can - and will- cause upward bias in V A and so h 2 . Let’s compare the estimates of heritability from each of models 1.2, 1.3 and 1.4: posterior.heritability1.3 &lt;- model1.3$VCV[, &quot;animal&quot;]/(model1.3$VCV[,&quot;animal&quot;] + model1.3$VCV[, &quot;byear&quot;] + model1.3$VCV[, &quot;units&quot;]) posterior.heritability1.4 &lt;- model1.4$VCV[, &quot;animal&quot;]/(model1.4$VCV[,&quot;animal&quot;] + model1.4$VCV[, &quot;byear&quot;] + model1.4$VCV[, &quot;mother&quot;] + model1.4$VCV[, &quot;units&quot;]) posterior.mode(posterior.heritability1.2) ## var1 ## 0.5125448 posterior.mode(posterior.heritability1.3) ## var1 ## 0.4750193 posterior.mode(posterior.heritability1.4) ## var1 ## 0.4352122 2.4.4 Testing significance of variance components While testing the significance of fixed effects by evaluating whether or not their posterior distributions overlap zero was simple and valid, this approach does not work for vari- ance components. Variance components are bound to be positive (given a proper prior), and thus even when a random effect is not meaningful, its posterior distribution will never overlap zero. Model comparisons can be performed using the deviance information criterion (DIC), although it should be noted that the properties of DIC are not well un- derstood and that the DIC may be focused at the wrong level for most people’s intended level of infernce - particularly with non-Gaussian responses. The implementation of DIC in MCMCglmm is further described in the reference manual. DIC values are calculated by MCMCglmm by default. Briefly, DIC like other information criteria balance model fit and model complexity simultaneously, and small values of DIC are prefered. We can compare models 1.4 and 1.3, i.e., models with and without the mother term: model1.3$DIC ## [1] 3546.14 model1.4$DIC ## [1] 3298.733 model 1.4 has a much lower DIC value. Since the maternal effect term is the only difference between the models, we can consider the inclusion of this term statistically justifiable. We should note however that DIC has a large sampling variance and should probably only be calculated based on much longer MCMC runs. "],["brms-1.html", "2.5 brms", " 2.5 brms library(brms) ## Loading required package: Rcpp ## Loading &#39;brms&#39; package (version 2.14.4). Useful instructions ## can be found by typing help(&#39;brms&#39;). A more detailed introduction ## to the package is available through vignette(&#39;brms_overview&#39;). ## ## Attaching package: &#39;brms&#39; ## The following object is masked from &#39;package:MCMCglmm&#39;: ## ## me ## The following object is masked from &#39;package:stats&#39;: ## ## ar Amat &lt;- nadiv::makeA(gryphonped) model_simple1.1 &lt;- brm( bwt ~ 1 + (1|animal), data = gryphon, family = gaussian(), cov_ranef = list(animal = Amat), chains = 2, cores = 2, iter = 1000 ) ## Warning: Argument &#39;cov_ranef&#39; is deprecated and will be removed in the future. ## Please use argument &#39;cov&#39; in function &#39;gr&#39; instead. ## Warning: Rows containing NAs were excluded from the model. ## Compiling Stan program... ## Start sampling ## Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#bulk-ess ## Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. ## Running the chains for more iterations may help. See ## http://mc-stan.org/misc/warnings.html#tail-ess summary(model_simple1.1) ## Family: gaussian ## Links: mu = identity; sigma = identity ## Formula: bwt ~ 1 + (1 | animal) ## Data: gryphon (Number of observations: 854) ## Samples: 2 chains, each with iter = 1000; warmup = 500; thin = 1; ## total post-warmup samples = 1000 ## ## Group-Level Effects: ## ~animal (Number of levels: 854) ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## sd(Intercept) 1.84 0.16 1.52 2.13 1.02 65 62 ## ## Population-Level Effects: ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## Intercept 7.59 0.14 7.30 7.85 1.00 371 497 ## ## Family Specific Parameters: ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## sigma 1.97 0.12 1.74 2.20 1.03 65 189 ## ## Samples were drawn using sampling(NUTS). For each parameter, Bulk_ESS ## and Tail_ESS are effective sample size measures, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). plot(model_simple1.1) "],["quick-comparison-of-codes.html", "Chapter 3 Quick comparison of codes ", " Chapter 3 Quick comparison of codes "],["univariate-model-with-repeated-measures.html", "3.1 Univariate model with repeated measures", " 3.1 Univariate model with repeated measures 3.1.1 Asreml-R 3.1.2 gremlin 3.1.3 MCMCglmm 3.1.4 brms library(brms) Amat &lt;- nadiv::makeA(gryphonped) model_simple1.1 &lt;- brm( bwt ~ 1 + (1|animal) + (1|animal_pe), data = gryphon, family = gaussian(), cov_ranef = list(animal = Amat), chains = 2, cores = 2, iter = 1000 ) summary(model_simple1.1) plot(model_simple1.1) "],["bivariate-model.html", "3.2 bivariate model", " 3.2 bivariate model 3.2.1 Asreml-R 3.2.2 gremlin 3.2.3 MCMCglmm 3.2.4 brms library(brms) Amat &lt;- nadiv::makeA(gryphonped) model_simple2.1 &lt;- brm( cbind(bwt, tarsus) ~ 1 + (1|animal), data = gryphon, family = gaussian(), cov_ranef = list(animal = Amat), chains = 2, cores = 2, iter = 1000 ) summary(model_simple2.1) plot(model_simple2.1) VarCorr(model_simple2.1) "],["references.html", "References", " References "]]
