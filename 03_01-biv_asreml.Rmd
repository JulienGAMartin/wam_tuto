## Asreml-R {#asreml-biv}

### Running the model


First we need to load the `asreml` library:
```{r}
library(asreml)
```

For running multivariate analyses in ASReml-R, the code is slightly more complex than for the univariate case. This is because ASReml-R allows us to make different assumptions about the way in which traits might be related. So we need to explicitly code a model of the (co)variance structure we want to fit by specified some starting values. These are can be very approximate _guestimates_, but having reasonable starting values can aid convergence. Finally, we have increased the default maximum number of iterations (`maxiter`) which can help to achieve convergence for more complicated models. Another way to increase the number of iteration will be to use the `update` function. Notes that if the `LogLik` is not stabilized after several iterations, it is good indication of the model require more iteration.


It is also possible to let the model running without any specify starting values but usually univariate model will allow to get some _guestimates_ in the additive genetic variances. 

```{r}
ainv <- ainverse(gryphonped)
modela <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait,
  random = ~ us(trait):vm(animal, ainv), init = c(1, 0.1, 1),
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
modela <- update(modela)
```

`modela` has fitted a bivariate model of `bwt` and `tarsus`, with the mean for each of the traits as a fixed effect (`trait`). The additive genetic variance-covariance matrix ($\textbf{G}$) is unstructured (`us`; _i.e._ all elements are free to vary) and the starting values for $V_A$ for `bwt`, $COV_A$ between `bwt` and `tarsus`, and $V_A$ for `tarsus` are set to 1, 0.1 and 1, respectively. Similarly, the residual matrix is unstructured and uses the same starting values.

Note that the argument `na.action = na.method(x = "include", y = "include")` can be added to the model. In a bivariate model, it will help calculate the covariance between two traits with different missing information `NA` and so help imbalance phenotypage and save sample size. However, it is important to scale ( mean =0, var =1) the two traits to correctly adjust the model(see Asreml-R manual for more information). 

Let's have a look at the variance components, and notice that there are now seven (co)variance components reported in the table:

```{r}
summary(modela)$varcomp
```

The first three terms are related to the genetic matrix and, in order are $V_{A,bwt}$, $COV_A$, $V_{A, tarsus}$. Below is again a line where the `units:traitr!R` component equals to 1, which again can be ignored. The final three terms relate to the residual matrix and correspond to $V_{R,bwt}$, $COV_R$, $V_{R,tarsus}$. Based on our quick and dirty check (is `z.ratio` > 1.96?) all components look to be statistically significant.

We can calculate the genetic correlation as $COV_A / \sqrt{V_{A,bwt} \cdot V_{A,tarsus}}$. Thus this model gives an estimate of $r_A$ = `r round(summary(modela)$varcomp[2,1]/sqrt(summary(modela)$varcomp[1,1]*summary(modela)$varcomp[3,1]), 2)`. It is also possible to estimate the residual correlation  $r_res$ = `r round(summary(modela)$varcomp[6,1]/sqrt(summary(modela)$varcomp[5,1]*summary(modela)$varcomp[7,1]), 2)`. 
<<<<<<< HEAD
<!-- C1 issue the annotation of the residual correlation-->

<!-- C2 Should we add an explication of the nature of the residual correlation or genetic correlation no? -->

=======
<!--  issue the annotation of the residual correlation-->
>>>>>>> 16f8809a82c6093bae5313d853ba4e62e635a3fc




Although we can calculate this by hand, we can also use `vpredict()`, which also provides an (approximate) standard error:
```{r}
vpredict(modela, r_A ~ V2 / sqrt(V1 * V3))
vpredict(modela, r_res ~ V6 / sqrt(V5 * V7))
```

Of course we can also calculate the heritability of `bwt` and `tarsus` from this model:
```{r}
vpredict(modela, h2.bwt ~ V1 / (V1 + V5))
vpredict(modela, h2.tarsus ~ V3 / (V3 + V7))
```


### Adding fixed and random effects

Fixed and random effects can be added just as for the univariate case. Given that our full model of bwt from tutorial 1 had sex as a fixed effect as well as birth year and mother as random effects, we could specify a bivariate formulation with the same complexity:

```{r}
modelb <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait):sex,
  random = ~ us(trait, init = c(1, 0.1, 1)):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
modelb <- update(modelb)
```

Note that we have specified a covariance structure for each random effect and an estimate of the effect of sex on both birth weight and tarsus length.
<!-- C3 trait:sex actually combined the effect of sex on both trait in the wald test, so I change it for at(trait): -->

There will now be thirteen (co)variance components reported after running the code:
```{r}
summary(modelb)$varcomp
```

we can estimate the different correlations using `vpredict`: 
```{r}
vpredict(modelb, r_byear ~ V2 / sqrt(V1 * V3))
vpredict(modelb, r_M ~ V5 / sqrt(V4 * V6))
vpredict(modelb, r_A ~ V8 / sqrt(V7 * V9))
vpredict(modelb, r_res ~ V12 / sqrt(V11 * V13))
```


Now we can look at the fixed effects parameters and assess their significance with a conditional Wald F-test:
```{r, eval = htmlT_pdfF}
summary(modelb, coef = TRUE)$coef.fi
wald.asreml(modelb, denDF = "default", ssType = "conditional")$Wald
```
```{r, echo = FALSE, eval = htmlF_pdfT}
summary(modelb, coef = TRUE)$coef.fi
wa <- wald.asreml(modelb, denDF = "default", ssType = "conditional")$Wald
attr(wa, "heading") <- NULL
wa
```


Note that it is possible to specify a fixed effect to a specific trait by adding the number of order within `cbind` inside the argument `at(trait,x)`. For example, here we apply the fixed effect `sex` only to the response variable `tarsus`. 

```{r}
modelb_2 <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait, 2):sex,
  random = ~ us(trait, init = c(1, 0.1, 1)):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
```
```{r, eval = htmlT_pdfF}
summary(modelb_2, coef = TRUE)$coef.fi
wald.asreml(modelb_2, denDF = "default", ssType = "conditional")$Wald
```

```{r, echo = FALSE, eval = htmlF_pdfT}
summary(modelb_2, coef = TRUE)$coef.fi
wa <- wald.asreml(modelb_2, denDF = "default", ssType = "conditional")$Wald
attr(wa, "heading") <- NULL
wa
```


### Significance testing

Under the model above $r_M$ is estimated as `r round(summary(modelb)$varcomp[5,1]/sqrt(summary(modelb)$varcomp[4,1]*summary(modelb)$varcomp[6,1]), 2)` and the `z.ratio` associated with the corresponding covariance ($COV_M$) is >2 (in absolute terms). We might therefore infer that there is evidence for a strong negative correlation between the traits with respect to the mother and that while maternal identity explains variance in both traits those mothers that tend to produce heavier offspring actually tend to produce offspring with shorter tarsus lengths.

To formally test if $COV_M$ is significantly different from zero, we can compare the log-likelihood for this model:
```{r}
modelb$loglik
```
to a model in which we specify that $COV_M$=0. Since this constraint reduces the number of parameters to be estimated by one, we can use a likelihood ratio test (LRT) with one degree of freedom. To run the constrained model, we modify the G structure defined for the `mother` random effect to diagonal (`diag`), which means we only estimate the variances (the diagonal of the matrix) but not the covariance (the covariance are fixed to 0):

```{r}
modelc <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait):sex,
  random = ~ us(trait, init = c(1, 0.1, 1)):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    diag(trait, init = c(1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
```

You can run `summary(modelc)$varcomp` to confirm this worked. We can now obtain the log-likelihood of this model and compare this to that of `modelb` using a likelihood ratio test:
```{r}
modelc$loglik
```

We can see that the model log-likelihood is now `r round(modelc$loglik, 2)`.
And comparing the models using a likelihood ratio test:
```{r}
2 * (modelb$loglik - modelc$loglik)
```
So our chi-square test statistic is $\chi^2_1$= `r round(2*(modelb$loglik-modelc$loglik),2)`.
The p-value that goes with this is obtained by:
```{r}
1 - pchisq(2 * (modelb$loglik - modelc$loglik), 1)
```
We would therefore conclude that the maternal covariance is significantly different from zero.

We could apply the same procedure to show that the residual (environmental) covariance and the genetic covariance estimates are significantly greater than zero (_i.e._, heavier individuals tend to have longer tarsus lengths). In contrast, we should find that the byear covariance between the two traits is non-significant.

```{r}
modeld <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait):sex,
  random = ~ us(trait, init = c(1, 0.1, 1)):vm(animal, ainv) +
    diag(trait, init = c(1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)

2 * (modelb$loglik - modeld$loglik)
1 - pchisq(2 * (modelb$loglik - modeld$loglik), 1)
```



### Estimate directly the genetic correlation within the model

Within Asreml-r, different matrix structure can be specify such as `us`,`corg`, `diag`, etc (cf see the Asreml-r guide). Instead of the fitting an unstructured matrix with the argument `us` or a reduced model with no covariance with the argument `diag`, we can also directly estimate the genetic correlation between the `bwt` and `tarsus` with `corgh`. 
Here we decide to estimate directly the additive genetic correlation.

<!-- C4 I dont know if we can specify initial values with corgh !, i remove it -->

```{r}
modele <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait):sex,
  random = ~ corgh(trait):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
modele <- update(modele)
summary(modele)$varcomp
```

It is important to note that using `corgh` change the order of the estimate (co)variance. All different calculation need to be adjust in consequence. 
It is also important to check the difference between the model with `us` and `corgh` to make sure any mistake are made.

```{r}
summary(modelb)$loglik
summary(modele)$loglik
```

There two main advantages to use `corgh`: first, a direct estimation of correlation within the G matrix can avoid mistake in the `vpredict` calculation; second, it is possible to test if the correlation is significantly different than 0 (similar result as LRT with the covariance) but also to -1 and 1 which correspond of the correlation boundaries.
The following code showed how to create a reduced model with the correlation close to 1 and compared to the initial model.
Since we compared the correlation to its boundary, the degree of freedom is only half as a one tail LTR.

```{r}
MODEL_MODIF <- update.asreml(modele, start.values = T)
G_MOD <- MODEL_MODIF$vparameters.table[(1:9), ]
G_MOD[1, 2] <- 0.99999
G_MOD[1, 3] <- "F"
modele.red <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait):sex,
  random = ~ corgh(trait):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20,
  G.param = G_MOD
)

2 * (modele$loglik - modele.red$loglik)
1 - pchisq(2 * (modele$loglik - modele.red$loglik), df = 0.5)
```

Here, the correlation is significantly different than 1 (~0.99999). 
<<<<<<< HEAD
=======


### Visualisation of the correlation (aka BLUP extraction)
When estimating correlation between traits, having a visualisation of it can help the interpretation. In addition, visualizing the correlation can spot outlier in the dataset.
Thanks to mixed model, each breeding values is stored within the model and can be extract as BLUP (Best Linear Unbiaised Predictor). 
BLUP should be normaly distributed, if not you need to check the assumption of your animal model.extract
>>>>>>> 16f8809a82c6093bae5313d853ba4e62e635a3fc

<!-- I think we need to define Breedign values and also BLUPs)-->
To simplify the following code, we rename the variable T1 and T2.

<<<<<<< HEAD
### Visualisation of the correlation (aka BLUP extraction)
When estimating correlation between traits, having a visualisation of it can help the interpretation. In addition, visualizing the correlation can spot outlier in the dataset.
Thanks to mixed model, each breeding values is stored within the model and can be extract as BLUP (Best Linear Unbiaised Predictor). 
BLUP should be normaly distributed, if not you need to check the assumption of your animal model.extract

<!-- C5 I think we need to define Breedign values and also BLUPs)-->
To simplify the following code, we rename the variable T1 and T2.

=======
>>>>>>> 16f8809a82c6093bae5313d853ba4e62e635a3fc
```{r}
gryphon$T1<-gryphon$bwt
gryphon$T2<-gryphon$tarsus
############
modele <- asreml(
  fixed = cbind(T1, T2) ~ trait + at(trait):sex,
  random = ~ corgh(trait):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ id(units):us(trait, init = c(1, 0.1, 1)),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
modele <- update(modele)
summary(modele)$varcomp
############
DvsS<-data.frame(Trait = rownames(modele$coefficients$random),
                 BLUP = modele$coefficients$random,
                 SE = sqrt(modele$vcoeff$random*modele$sigma2))
DvsS$ID<-substr(DvsS$Trait, 27,30)
DvsS$TRAIT<-substr(DvsS$Trait, 7,8)
DvsS<-DvsS[927:3544,] #keep only row associated to animal 
summary(factor(DvsS$TRAIT)) # 1309 each
#
DvsS$Trait<-NULL
colnames(DvsS)[1]<-"BLUP"
BLUPS<-reshape(DvsS, v.names = c("BLUP","SE"), idvar = "ID",timevar = "TRAIT", direction = "wide")
nrow(BLUPS)
rownames(BLUPS) <- c()
colnames(BLUPS) <- c("ID","BLUP.btw","SE.btw","BLUP.tarsus","SE.tarsus")
summary(BLUPS)
write.csv(BLUPS,file="BLUPS_6x6.csv",row.names=F)
############
par(mfrow=c(2,2))
  hist(BLUPS$BLUP.btw)
qqnorm(BLUPS$BLUP.btw)
qqline(BLUPS$BLUP.btw)
  hist(BLUPS$BLUP.tarsus)
qqnorm(BLUPS$BLUP.tarsus)
qqline(BLUPS$BLUP.tarsus)
#
plot(BLUP.tarsus~BLUP.btw,BLUPS,xlab="",ylab="", las=1.2, bty="o", col="white")
arrows(x0=BLUPS$BLUP.btw,y0=BLUPS$BLUP.tarsus-BLUPS$SE.tarsus,x1=BLUPS$BLUP.btw,y1=BLUPS$BLUP.tarsus+BLUPS$SE.tarsus,col="black",code=3,angle=90,length=0)
arrows(x0=BLUPS$BLUP.btw-BLUPS$SE.btw,y0=BLUPS$BLUP.tarsus,x1=BLUPS$BLUP.btw+BLUPS$SE.btw,y1=BLUPS$BLUP.tarsus,col="black",code=3,angle=90,length=0)
points(BLUP.tarsus~BLUP.btw,BLUPS,pch=16,col="red", cex=1.5)
points(BLUP.tarsus~BLUP.btw,BLUPS,pch=1, col=rgb(0,0,0,0.3), cex=c(1.5))
mtext("btw (BV±SE)",  side=1, line=2.4)
mtext("tarsus (BV±SE)",  side=2, line=2,las=3)
mtext(expression(paste(italic(r)[A]," = 0.7353065 ±  0.1094838")),side=1,line=-1,adj=0.95,cex=0.9)
```

### Partitionning (co)variance between groups 

Similar to the univariate model, it is possible to partition the variance and also the covariance between different groups within the dataset. Here, we can estimate sex-specific genetic correlation. 
Note, to partition a correlation, it is require to have important sample size within each group. For this example, we simplify the model !

<<<<<<< HEAD
=======
<!-- SAme here I don't know how to specify initial values so I remove it -->
>>>>>>> 16f8809a82c6093bae5313d853ba4e62e635a3fc

```{r}
gryphon <- gryphon[order(gryphon$sex), ]
model_sex <- asreml(
  fixed = cbind(bwt, tarsus) ~ trait + at(trait):sex,
  random = ~ at(sex):us(trait):vm(animal, ainv) +
    us(trait, init = c(1, 0.1, 1)):byear +
    us(trait, init = c(1, 0.1, 1)):mother,
  residual = ~ dsum(~ id(units):us(trait) | sex),
  data = gryphon,
  na.action = na.method(x = "include", y = "include"),
  maxit = 20
)
model_sex <- update(model_sex)
summary(model_sex)$varcomp
```


we can estimate the different correlations using `vpredict`:  
```{r}
vpredict(model_sex, r_byear ~ V2 / sqrt(V1 * V3))
vpredict(model_sex, r_M ~ V5 / sqrt(V4 * V6))

vpredict(model_sex, r_A.1 ~ V8 / sqrt(V7 * V9))
vpredict(model_sex, r_A.2 ~ V11 / sqrt(V10 * V12))

vpredict(model_sex, r_res.1 ~ V15 / sqrt(V14 * V16))
vpredict(model_sex, r_res.2 ~ V19 / sqrt(V18 * V20))
```

and the heritability too:
```{r}
vpredict(model_sex, h2.bwt.1 ~ V7 / (V1 + V4 + V7 + V14))
vpredict(model_sex, h2.bwt.2 ~ V10 / (V1 + V4 + V10 + V18))

vpredict(model_sex, h2.tarsus.1 ~ V9 / (V3 + V6 + V9 + V16))
vpredict(model_sex, h2.tarsus.2 ~ V12 / (V3 + V6 + V12 + V20))
```



Now we can look at the fixed effects parameters and assess their significance with a conditional Wald F-test:
```{r, eval = htmlT_pdfF}
summary(model_sex, coef = TRUE)$coef.fi
wald.asreml(model_sex, denDF = "default", ssType = "conditional")$Wald
```

```{r, echo = FALSE, eval = htmlF_pdfT}
summary(model_sex, coef = TRUE)$coef.fi
wa <- wald.asreml(model_sex, denDF = "default", ssType = "conditional")$Wald
attr(wa, "heading") <- NULL
wa
```

<<<<<<< HEAD
<!-- C6  what do I need to add ?  comparison model partitionn and not !

=======
<!--  what do I need to add ?  comparison model partitionn and not !
>>>>>>> 16f8809a82c6093bae5313d853ba4e62e635a3fc

