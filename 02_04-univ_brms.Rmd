## brms

### Running the model

First we need to load the `brms` library:
```{r}
library(brms)
```
To be able to fit an animal model, `brms` needs the relativeness (relationship) matrix of the pedigree and not its inverse (as in other softwares).
This can be estimated using the `nadiv` package created by Matthew Wolak (https://cran.r-project.org/web/packages/nadiv/index.html).

```{r}
Amat <- as.matrix(nadiv::makeA(gryphonped))
```

We are now ready to specify our first model:
The structure of a `bmrs` model is similar to `lme4`, thus the random effect is added to the model with the term `(1 | gr(animal, cov = Amat)` which associate the id animal to the matrix of relativeness. 
In addition to the synthase of `lme4`, we includes other features or parameters within the models such as `chain` which represent the number of Markov chains (defaults to 4), `core` which represents the number of cores to use when executing the chains in parallel and `iter` which represents the number of total iterations per chain. For more parameters such as `thin` or `warmup/burnin`, you can read the Cran R page of the package (https://cran.r-project.org/web/packages/brms/brms.pdf)

<!-- C8 : we did not fit a prior to the model, is it normal? !-->
`bmrs` is a Bayesian Multilevel Models using Stan, doing so we can apply a prior to the model to better shape the distribution of the different variances estimated by the model. 
Thanks to `get_prior`, a uninformative prior can be produce using the same equation as the model itself.

```{r eval = params$fit_all}
priors_m1.1<-get_prior( bwt ~ 1 + (1 | gr(animal, cov = Amat)),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian())  
  
brms_m1.1 <- brm(
  bwt ~ 1 + (1 | gr(animal, cov = Amat)),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian(),
  prior = priors_m1.1,
  chains = 1, cores = 1, iter = 100
)

save(brms_m1.1, file = "data/brms_m1_1.rda")
```


The result of the long model calculation is save in a spare file `brms_m1_1.rda"`. To help readers, we can directly  reloading it.
Two distinct plot can be produce to produce some diagnostics graphs `mcmc_plot`.Note, that `sigma` represents the residual standard deviation.

Next,we examine (or directly using the model) the variance estimate and their distributions (via `summary` or plot). 

```{r}
load("data/brms_m1_1.rda")
plot(brms_m1.1)
mcmc_plot(brms_m1.1, type = "acf")
summary(brms_m1.1)
```

The `plot` of variance showed that the different variances have an normal distribution, the autocorrelation plot or 'acf' show that the autocorrelation is close to 0.
The `summary` exposes the  mean (Estimate) of each variance or fixed effect (here just the intercept) associated to their posterior distribution with standard deviation (Est.Error) and two-sided 95% Credible intervals. 
`Rhat` provides information on the estimate convergence. If it's greater than 1, the chains have not yet converged and it will be require to run more iterations and/or set stronger priors. 
`ESS` represents the Effective sample values as the number of independent samples from the posterior distribution.
However, for the purpose of this guide, the Rhat values are acceptable.

It is also possible to calculate the heritability using the function 'as.mcmc'

```{r}
v_animal <- (VarCorr(brms_m1.1, summary = FALSE)$animal$sd)^2
v_r <- (VarCorr(brms_m1.1, summary = FALSE)$residual$sd)^2
h.bwt.1 <- as.mcmc(v_animal / (v_animal + v_r))
summary(h.bwt.1)
plot(h.bwt.1)
```


### Adding fixed effects

To add effects to a univariate model, we simply modify the priors and the fixed effect portion of the model specification:

```{r eval = params$fit_all}
priors_m1.2<-get_prior( bwt ~ 1 + sex + (1 | gr(animal, cov = Amat)),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian())  
  
brms_m1.2 <- brm(
  bwt ~ 1 + sex + (1 | gr(animal, cov = Amat)),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian(),
  prior = priors_m1.2,
  chains = 2, cores = 2, iter = 1000
)

save(brms_m1.2, file = "data/brms_m1_2.rda")
```

To save time, the results of the calculation is stored in the spare file `brms_m1_2.rda"`. 
We can assess the significance of `sex` as a fixed effect by examining its posterior distribution.

```{r}
load("data/brms_m1_2.rda")
summary(brms_m1.2)
plot(brms_m1.2)
mcmc_plot(brms_m1.2, type = "pairs")


summary(brms_m1.2)$fixed
summary(brms_m1.2)$random
```


The posterior distribution of the `sex2` term does not overlap zero. Thus, we can infer that sex has an effect on birth weight (presence of a sexual dimorphism) in this model and is a useful addition to the model, for most purposes. It is also worth noting that the variance components have changed slightly:

```{r}
summary(brms_m1.2)$random
```

In fact since sex effects were previously contributing to the residual variance of the model our estimate of $V_R$ (denoted ’units’ in the output) is now slightly lower than before. This has an important consequence for estimating heritability since if we calculate $V_P$ as $V_A +V_R$ then as we include fixed effects we will soak up more residual variance driving $V_P$ . Assuming that $V_A$ is more or less unaffected by the fixed effects fitted then as $V_P$ goes down we expect our estimate of $h^2$ will go up.

```{r}
v_animal <- (VarCorr(brms_m1.2, summary = FALSE)$animal$sd)^2
v_r <- (VarCorr(brms_m1.2, summary = FALSE)$residual$sd)^2
h.bwt.2 <- as.mcmc(v_animal / (v_animal + v_r))

summary(h.bwt.2)
summary(h.bwt.1)
```

Here $h^2$ has increased slightly from 0.5010 to 0.4192 (again, your values may differ slightly due to Monte Carlo error). Which is the better estimate? 
It depends on what your question is. The first is an estimate of the proportion of variance in birth weight explained by additive effects, the latter is an estimate of the proportion of variance in birth weight after conditioning on sex that is explained by additive effects.
An important piece of advice, each researcher should be consistent in how they name their estimates and always correctly describe which estimates they are using conditional or not (to avoid any confusion).


### Adding random effects

This is done by simply modifying the model statement in the same way, but requires addition of a prior for the new random effect. For instance, we can fit an effect of birth year:


```{r, eval = params$fit_all}
priors_m1.3<-get_prior( bwt ~ 1 + sex + (1 | gr(animal, cov = Amat))+ (1 | byear) + (1 | mother),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian())  
  
brms_m1.3 <- brm(
  bwt ~ 1 + sex + (1 | gr(animal, cov = Amat)) + (1 | byear) + (1 | mother),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian(),
  prior = priors_m1.3,
  chains = 2, cores = 2, iter = 1000
)

save(brms_m1.3, file = "data/brms_m1_3.rda")
```

To save time, the results of the calculation is stored in the spare file `brms_m1_3.rda"`. 
We can assess the significance of `sex` as a fixed effect by examining its posterior distribution.

```{r}
load("data/brms_m1_3.rda")

plot(brms_m1.3, ask = FALSE, N = 3)
summary(brms_m1.2)$random
```

Here partitioning of significant birth year and maternal variance has resulted in a further decrease in $V_R$ but also a decrease in $V_A$. The latter is because maternal effects of the sort we simulated (fixed differences between mothers) will have the consequence of increasing similarity among maternal siblings. Consequently they can look very much like an additive genetic effects and if present, but unmodelled, represent a type of ‘common environment effect’ that can - and will- cause upward bias in $V_A$ and so $h^2$. Let’s compare the estimates of heritability from each of models 1.2, 1.3 and 1.4:

```{r}
v_animal <- (VarCorr(brms_m1.3, summary = FALSE)$animal$sd)^2
v_byear <- (VarCorr(brms_m1.3, summary = FALSE)$byear$sd)^2
v_mother <- (VarCorr(brms_m1.3, summary = FALSE)$mother$sd)^2
v_r <- (VarCorr(brms_m1.3, summary = FALSE)$residual$sd)^2
h.bwt.3 <- as.mcmc(v_animal / (v_animal + v_byear + v_mother + v_r))

summary(h.bwt.3)
summary(h.bwt.1)
```


### Testing significance of variance components

<!--C10 how to compare models?  -->
While testing the significance of fixed effects by evaluating whether or not their posterior distributions overlap zero was simple and valid, this approach does not work for variance components. 
Variance components are bounded to be positive (given a proper prior), and thus even when a random effect is not meaningful, its posterior distribution will never overlap zero. 

Model comparisons can be performed using the function `loo_compare` using `waic` or weighted AIC.

```{r}
brms_m1.3 <- add_criterion(brms_m1.3, "waic")
brms_m1.1 <- add_criterion(brms_m1.1, "waic")

loo_compare(brms_m1.3,brms_m1.1, criterion = "waic")

```


### Further partitioning of the variance

Depending of the research question and the presence of different group within the dataset, `brms` allowed to partition the variance at different groups. 
For the example, we can partition the additive genetic and residual variance between sex (male and female) to estimate the sex-specific heritability 

 <!-- C6 need to check the code  I never partition a random effect with lme4 + need to apply it to the residual level too, more too do here -->

```{r eval = params$fit_all}
brms_m1.4 <- brm(
  bwt ~ 1 + sex + (1 | gr(animal, cov = Amat)) + (1 | byear) + (1 | mother),
  data = gryphon,
  data2 = list(Amat = Amat),
  family = gaussian(),
  chains = 2, cores = 2, iter = 1000
)
save(brms_m1.4, file = "data/brms_m1_4.rda")
```

```{r}
load("data/brms_m1_4.rda")
summary(brms_m1.4)
plot(brms_m1.4, ask = FALSE, N = 3)
```


### Modification of model parameter

### Covariance between two random effects
